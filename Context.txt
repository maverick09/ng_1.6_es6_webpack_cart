
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { useEnableMock, MockType } from '../useEnableMock'

// Mock the dynamic imports
const mockServerWorker = {
  listen: vi.fn().mockResolvedValue(undefined)
}

const mockBrowserWorker = {
  start: vi.fn().mockResolvedValue(undefined)
}

const mockMicroAppWorker = {
  start: vi.fn().mockResolvedValue(undefined)
}

// Mock dynamic imports
vi.mock('../../../../../../mock-service-worker/server', () => ({
  default: mockServerWorker
}))

vi.mock('../../../../../../mock-service-worker/browser', () => ({
  default: mockBrowserWorker
}))

// Mock console methods
const consoleSpy = {
  log: vi.spyOn(console, 'log').mockImplementation(() => {}),
  warn: vi.spyOn(console, 'warn').mockImplementation(() => {}),
  error: vi.spyOn(console, 'error').mockImplementation(() => {})
}

// Mock import.meta.env
Object.defineProperty(import.meta, 'env', {
  value: {
    MODE: 'test'
  },
  writable: true
})

describe('useEnableMock', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    // Reset import.meta.env.MODE to test
    import.meta.env.MODE = 'test'
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  describe('ServerMock', () => {
    it('should initialize with mocks disabled', () => {
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      expect(result.current).toBe(false)
    })

    it('should enable ServerMock successfully when in test environment', async () => {
      import.meta.env.MODE = 'test'
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      // Wait for the effect to complete
      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockServerWorker.listen).toHaveBeenCalledTimes(1)
      expect(consoleSpy.log).toHaveBeenCalledWith('MSW server started successfully in test environment')
      expect(result.current).toBe(true)
    })

    it('should not enable ServerMock when not in test environment', async () => {
      import.meta.env.MODE = 'production'
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockServerWorker.listen).not.toHaveBeenCalled()
      expect(result.current).toBe(false)
    })

    it('should handle ServerMock startup errors', async () => {
      import.meta.env.MODE = 'test'
      const error = new Error('Server startup failed')
      mockServerWorker.listen.mockRejectedValueOnce(error)
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(consoleSpy.error).toHaveBeenCalledWith('Failed to start MSW:', error)
      expect(result.current).toBe(false)
    })
  })

  describe('BrowserMock', () => {
    it('should enable BrowserMock successfully', async () => {
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.BrowserMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockBrowserWorker.start).toHaveBeenCalledWith({
        serviceWorker: {
          url: '/mockServiceWorker.js'
        }
      })
      expect(consoleSpy.log).toHaveBeenCalledWith('MSW worker started successfully in browser')
      expect(result.current).toBe(true)
    })

    it('should handle BrowserMock startup errors', async () => {
      const error = new Error('Browser worker startup failed')
      mockBrowserWorker.start.mockRejectedValueOnce(error)
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.BrowserMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(consoleSpy.error).toHaveBeenCalledWith('Failed to start MSW:', error)
      expect(result.current).toBe(false)
    })
  })

  describe('MicroAppMock', () => {
    it('should enable MicroAppMock with valid import path', async () => {
      const mockImportPath = './micro-app-handlers'
      
      // Mock the dynamic import for micro app
      vi.doMock(mockImportPath, () => ({
        default: mockMicroAppWorker
      }))

      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: MockType.MicroAppMock, 
          microAppImportPath: mockImportPath 
        })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockMicroAppWorker.start).toHaveBeenCalledWith({
        serviceWorker: {
          url: '/mockServiceWorker.js',
          scope: '/'
        }
      })
      expect(consoleSpy.log).toHaveBeenCalledWith('Micro app MSW worker started successfully')
      expect(result.current).toBe(true)
    })

    it('should warn when MicroAppMock selected but no import path provided', async () => {
      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: MockType.MicroAppMock, 
          microAppImportPath: '' 
        })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(consoleSpy.warn).toHaveBeenCalledWith(
        'MicroAppMock selected, but no microAppImportPath provided'
      )
      expect(result.current).toBe(false)
    })

    it('should handle MicroAppMock startup errors', async () => {
      const mockImportPath = './micro-app-handlers'
      const error = new Error('Micro app worker startup failed')
      
      // Mock the dynamic import to return a worker that fails
      const failingWorker = {
        start: vi.fn().mockRejectedValue(error)
      }
      
      vi.doMock(mockImportPath, () => ({
        default: failingWorker
      }))

      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: MockType.MicroAppMock, 
          microAppImportPath: mockImportPath 
        })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(consoleSpy.error).toHaveBeenCalledWith('Failed to start MSW:', error)
      expect(result.current).toBe(false)
    })
  })

  describe('Invalid MockType', () => {
    it('should warn about invalid mock type', async () => {
      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: 'InvalidType' as MockType, 
          microAppImportPath: '' 
        })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(consoleSpy.warn).toHaveBeenCalledWith('Invalid mock type provided')
      expect(result.current).toBe(false)
    })
  })

  describe('Hook dependency changes', () => {
    it('should re-run effect when mockType changes', async () => {
      const { result, rerender } = renderHook(
        ({ mockType, microAppImportPath }) => 
          useEnableMock({ mockType, microAppImportPath }),
        {
          initialProps: { 
            mockType: MockType.BrowserMock, 
            microAppImportPath: '' 
          }
        }
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockBrowserWorker.start).toHaveBeenCalledTimes(1)
      vi.clearAllMocks()

      // Change to ServerMock
      import.meta.env.MODE = 'test'
      rerender({ 
        mockType: MockType.ServerMock, 
        microAppImportPath: '' 
      })

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockServerWorker.listen).toHaveBeenCalledTimes(1)
    })

    it('should re-run effect when microAppImportPath changes', async () => {
      const mockImportPath1 = './micro-app-handlers-1'
      const mockImportPath2 = './micro-app-handlers-2'
      
      const mockWorker1 = { start: vi.fn().mockResolvedValue(undefined) }
      const mockWorker2 = { start: vi.fn().mockResolvedValue(undefined) }
      
      vi.doMock(mockImportPath1, () => ({ default: mockWorker1 }))
      vi.doMock(mockImportPath2, () => ({ default: mockWorker2 }))

      const { rerender } = renderHook(
        ({ mockType, microAppImportPath }) => 
          useEnableMock({ mockType, microAppImportPath }),
        {
          initialProps: { 
            mockType: MockType.MicroAppMock, 
            microAppImportPath: mockImportPath1 
          }
        }
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockWorker1.start).toHaveBeenCalledTimes(1)
      
      // Change import path
      rerender({ 
        mockType: MockType.MicroAppMock, 
        microAppImportPath: mockImportPath2 
      })

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      expect(mockWorker2.start).toHaveBeenCalledTimes(1)
    })
  })

  describe('Cleanup', () => {
    it('should not cause memory leaks when component unmounts', async () => {
      const { unmount } = renderHook(() => 
        useEnableMock({ mockType: MockType.BrowserMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      // Should not throw when unmounting
      expect(() => unmount()).not.toThrow()
    })
  })
})
