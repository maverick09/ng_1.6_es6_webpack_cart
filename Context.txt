import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { renderHook, act, waitFor } from '@testing-library/react'
import { useEnableMock, MockType } from '../useEnableMock'

// Mock the dynamic imports with proper factory functions
const mockServerWorker = {
  listen: vi.fn().mockResolvedValue(undefined)
}

const mockBrowserWorker = {
  start: vi.fn().mockResolvedValue(undefined)
}

const mockMicroAppWorker = {
  start: vi.fn().mockResolvedValue(undefined)
}

// Mock console methods
const consoleSpy = {
  log: vi.spyOn(console, 'log').mockImplementation(() => {}),
  warn: vi.spyOn(console, 'warn').mockImplementation(() => {}),
  error: vi.spyOn(console, 'error').mockImplementation(() => {})
}

// Mock import() function globally
const mockImport = vi.fn()
vi.stubGlobal('import', mockImport)

// Helper to setup import mocks
const setupImportMocks = () => {
  mockImport.mockImplementation((path: string) => {
    if (path.includes('mock-service-worker/server')) {
      return Promise.resolve({ default: mockServerWorker })
    }
    if (path.includes('mock-service-worker/browser')) {
      return Promise.resolve({ default: mockBrowserWorker })
    }
    if (path.includes('micro-app')) {
      return Promise.resolve({ default: mockMicroAppWorker })
    }
    return Promise.reject(new Error(`Unknown import path: ${path}`))
  })
}

// Mock import.meta.env
const mockEnv = {
  MODE: 'test'
}

vi.stubGlobal('import', {
  ...mockImport,
  meta: {
    env: mockEnv
  }
})

describe('useEnableMock', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    setupImportMocks()
    // Reset environment
    mockEnv.MODE = 'test'
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  describe('ServerMock', () => {
    it('should initialize with mocks disabled', () => {
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      expect(result.current).toBe(false)
    })

    it('should enable ServerMock successfully when in test environment', async () => {
      mockEnv.MODE = 'test'
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      // Wait for the async effect to complete
      await waitFor(() => {
        expect(result.current).toBe(true)
      }, { timeout: 1000 })

      expect(mockImport).toHaveBeenCalledWith(expect.stringContaining('mock-service-worker/server'))
      expect(mockServerWorker.listen).toHaveBeenCalledTimes(1)
      expect(consoleSpy.log).toHaveBeenCalledWith('MSW server started successfully in test environment')
    })

    it('should not enable ServerMock when not in test environment', async () => {
      mockEnv.MODE = 'production'
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 100))
      })

      expect(mockImport).not.toHaveBeenCalled()
      expect(mockServerWorker.listen).not.toHaveBeenCalled()
      expect(result.current).toBe(false)
    })

    it('should handle ServerMock startup errors', async () => {
      mockEnv.MODE = 'test'
      const error = new Error('Server startup failed')
      
      // Mock the import to return a failing worker
      mockImport.mockImplementationOnce(() => 
        Promise.resolve({ 
          default: { 
            listen: vi.fn().mockRejectedValue(error) 
          } 
        })
      )
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.ServerMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 100))
      })

      expect(consoleSpy.error).toHaveBeenCalledWith('Failed to start MSW:', error)
      expect(result.current).toBe(false)
    })
  })

  describe('BrowserMock', () => {
    it('should enable BrowserMock successfully', async () => {
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.BrowserMock, microAppImportPath: '' })
      )

      await waitFor(() => {
        expect(result.current).toBe(true)
      }, { timeout: 1000 })

      expect(mockImport).toHaveBeenCalledWith(expect.stringContaining('mock-service-worker/browser'))
      expect(mockBrowserWorker.start).toHaveBeenCalledWith({
        serviceWorker: {
          url: '/mockServiceWorker.js'
        }
      })
      expect(consoleSpy.log).toHaveBeenCalledWith('MSW worker started successfully in browser')
    })

    it('should handle BrowserMock startup errors', async () => {
      const error = new Error('Browser worker startup failed')
      
      mockImport.mockImplementationOnce(() => 
        Promise.resolve({ 
          default: { 
            start: vi.fn().mockRejectedValue(error) 
          } 
        })
      )
      
      const { result } = renderHook(() => 
        useEnableMock({ mockType: MockType.BrowserMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 100))
      })

      expect(consoleSpy.error).toHaveBeenCalledWith('Failed to start MSW:', error)
      expect(result.current).toBe(false)
    })
  }))

  describe('MicroAppMock', () => {
    it('should enable MicroAppMock with valid import path', async () => {
      const mockImportPath = './micro-app-handlers'
      
      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: MockType.MicroAppMock, 
          microAppImportPath: mockImportPath 
        })
      )

      await waitFor(() => {
        expect(result.current).toBe(true)
      }, { timeout: 1000 })

      expect(mockImport).toHaveBeenCalledWith(mockImportPath)
      expect(mockMicroAppWorker.start).toHaveBeenCalledWith({
        serviceWorker: {
          url: '/mockServiceWorker.js',
          scope: '/'
        }
      })
      expect(consoleSpy.log).toHaveBeenCalledWith('Micro app MSW worker started successfully')
    })

    it('should warn when MicroAppMock selected but no import path provided', async () => {
      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: MockType.MicroAppMock, 
          microAppImportPath: '' 
        })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 100))
      })

      expect(consoleSpy.warn).toHaveBeenCalledWith(
        'MicroAppMock selected, but no microAppImportPath provided'
      )
      expect(mockImport).not.toHaveBeenCalled()
      expect(result.current).toBe(false)
    })

    it('should handle MicroAppMock startup errors', async () => {
      const mockImportPath = './micro-app-handlers'
      const error = new Error('Micro app worker startup failed')
      
      mockImport.mockImplementationOnce(() => 
        Promise.resolve({ 
          default: { 
            start: vi.fn().mockRejectedValue(error) 
          } 
        })
      )

      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: MockType.MicroAppMock, 
          microAppImportPath: mockImportPath 
        })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 100))
      })

      expect(consoleSpy.error).toHaveBeenCalledWith('Failed to start MSW:', error)
      expect(result.current).toBe(false)
    })
  }))

  describe('Invalid MockType', () => {
    it('should warn about invalid mock type', async () => {
      const { result } = renderHook(() => 
        useEnableMock({ 
          mockType: 'InvalidType' as MockType, 
          microAppImportPath: '' 
        })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 100))
      })

      expect(consoleSpy.warn).toHaveBeenCalledWith('Invalid mock type provided')
      expect(mockImport).not.toHaveBeenCalled()
      expect(result.current).toBe(false)
    })
  })

  describe('Hook dependency changes', () => {
    it('should re-run effect when mockType changes', async () => {
      const { result, rerender } = renderHook(
        ({ mockType, microAppImportPath }) => 
          useEnableMock({ mockType, microAppImportPath }),
        {
          initialProps: { 
            mockType: MockType.BrowserMock, 
            microAppImportPath: '' 
          }
        }
      )

      await waitFor(() => {
        expect(result.current).toBe(true)
      })

      expect(mockImport).toHaveBeenCalledWith(expect.stringContaining('mock-service-worker/browser'))
      
      // Reset mocks and change to ServerMock
      vi.clearAllMocks()
      setupImportMocks()
      mockEnv.MODE = 'test'
      
      rerender({ 
        mockType: MockType.ServerMock, 
        microAppImportPath: '' 
      })

      await waitFor(() => {
        expect(mockImport).toHaveBeenCalledWith(expect.stringContaining('mock-service-worker/server'))
      })
    })

    it('should re-run effect when microAppImportPath changes', async () => {
      const mockImportPath1 = './micro-app-handlers-1'
      const mockImportPath2 = './micro-app-handlers-2'
      
      const { rerender } = renderHook(
        ({ mockType, microAppImportPath }) => 
          useEnableMock({ mockType, microAppImportPath }),
        {
          initialProps: { 
            mockType: MockType.MicroAppMock, 
            microAppImportPath: mockImportPath1 
          }
        }
      )

      await waitFor(() => {
        expect(mockImport).toHaveBeenCalledWith(mockImportPath1)
      })
      
      // Reset and change import path
      vi.clearAllMocks()
      setupImportMocks()
      
      rerender({ 
        mockType: MockType.MicroAppMock, 
        microAppImportPath: mockImportPath2 
      })

      await waitFor(() => {
        expect(mockImport).toHaveBeenCalledWith(mockImportPath2)
      })
    })
  })

  describe('Cleanup', () => {
    it('should not cause memory leaks when component unmounts', async () => {
      const { unmount } = renderHook(() => 
        useEnableMock({ mockType: MockType.BrowserMock, microAppImportPath: '' })
      )

      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 0))
      })

      // Should not throw when unmounting
      expect(() => unmount()).not.toThrow()
    })
  })
})
